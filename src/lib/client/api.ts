/* tslint:disable */
/* eslint-disable */
/**
 * Î»ORM Service
 * service of lambda orm
 *
 * The version of the OpenAPI document: 0.3.0
 * Contact: flaviolrita@hotmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { RequestArgs, BaseAPI } from './base';

/**
 * 
 * @export
 * @interface Constraint
 */
export interface Constraint {
    /**
     * 
     * @type {string}
     * @memberof Constraint
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Constraint
     */
    'condition': string;
}
/**
 * 
 * @export
 * @interface DataSource
 */
export interface DataSource {
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'dialect': string;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'mapping': string;
    /**
     * 
     * @type {any}
     * @memberof DataSource
     */
    'connection': any;
}
/**
 * 
 * @export
 * @interface Dependent
 */
export interface Dependent {
    /**
     * 
     * @type {string}
     * @memberof Dependent
     */
    'entity': string;
    /**
     * 
     * @type {Relation}
     * @memberof Dependent
     */
    'relation': Relation;
}
/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'extends'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Entity
     */
    'abstract'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'singular'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    'uniqueKey': Array<string>;
    /**
     * 
     * @type {Array<Index>}
     * @memberof Entity
     */
    'indexes': Array<Index>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    'primaryKey': Array<string>;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Entity
     */
    'properties': Array<Property>;
    /**
     * 
     * @type {Array<Relation>}
     * @memberof Entity
     */
    'relations': Array<Relation>;
    /**
     * 
     * @type {Array<Dependent>}
     * @memberof Entity
     */
    'dependents': Array<Dependent>;
    /**
     * 
     * @type {Array<Constraint>}
     * @memberof Entity
     */
    'constraints'?: Array<Constraint>;
}
/**
 * 
 * @export
 * @interface EntityMapping
 */
export interface EntityMapping {
    /**
     * 
     * @type {string}
     * @memberof EntityMapping
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EntityMapping
     */
    'extends'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntityMapping
     */
    'abstract'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EntityMapping
     */
    'singular'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityMapping
     */
    'uniqueKey': Array<string>;
    /**
     * 
     * @type {Array<Index>}
     * @memberof EntityMapping
     */
    'indexes': Array<Index>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntityMapping
     */
    'primaryKey': Array<string>;
    /**
     * 
     * @type {Array<PropertyMapping>}
     * @memberof EntityMapping
     */
    'properties': Array<PropertyMapping>;
    /**
     * 
     * @type {Array<Relation>}
     * @memberof EntityMapping
     */
    'relations': Array<Relation>;
    /**
     * 
     * @type {Array<Dependent>}
     * @memberof EntityMapping
     */
    'dependents': Array<Dependent>;
    /**
     * 
     * @type {Array<Constraint>}
     * @memberof EntityMapping
     */
    'constraints'?: Array<Constraint>;
    /**
     * 
     * @type {string}
     * @memberof EntityMapping
     */
    'mapping': string;
}
/**
 * 
 * @export
 * @interface Enum
 */
export interface Enum {
    /**
     * 
     * @type {string}
     * @memberof Enum
     */
    'name': string;
    /**
     * 
     * @type {Array<EnumValue>}
     * @memberof Enum
     */
    'values': Array<EnumValue>;
}
/**
 * 
 * @export
 * @interface EnumValue
 */
export interface EnumValue {
    /**
     * 
     * @type {string}
     * @memberof EnumValue
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof EnumValue
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Health
     */
    'time': string;
    /**
     * 
     * @type {number}
     * @memberof Health
     */
    'uptime': number;
}
/**
 * 
 * @export
 * @interface Index
 */
export interface Index {
    /**
     * 
     * @type {string}
     * @memberof Index
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Index
     */
    'fields': Array<string>;
}
/**
 * 
 * @export
 * @interface Mapping
 */
export interface Mapping {
    /**
     * 
     * @type {string}
     * @memberof Mapping
     */
    'extends'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mapping
     */
    'mapping'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mapping
     */
    'name': string;
    /**
     * 
     * @type {Array<EntityMapping>}
     * @memberof Mapping
     */
    'entities': Array<EntityMapping>;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'entity'?: string;
    /**
     * 
     * @type {Array<Metadata>}
     * @memberof Metadata
     */
    'children'?: Array<Metadata>;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Metadata
     */
    'fields'?: Array<Property>;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'property'?: string;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof Metadata
     */
    'parameters'?: Array<Parameter>;
    /**
     * 
     * @type {Relation}
     * @memberof Metadata
     */
    'relation'?: Relation;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'sentence'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'alias'?: string;
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface MetadataConstraint
 */
export interface MetadataConstraint {
    /**
     * 
     * @type {string}
     * @memberof MetadataConstraint
     */
    'entity': string;
    /**
     * 
     * @type {Array<Constraint>}
     * @memberof MetadataConstraint
     */
    'constraints': Array<Constraint>;
    /**
     * 
     * @type {Array<MetadataConstraint>}
     * @memberof MetadataConstraint
     */
    'children'?: Array<MetadataConstraint>;
}
/**
 * 
 * @export
 * @interface MetadataModel
 */
export interface MetadataModel {
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataModel
     */
    'type': string;
    /**
     * 
     * @type {Array<MetadataModel>}
     * @memberof MetadataModel
     */
    'children'?: Array<MetadataModel>;
}
/**
 * 
 * @export
 * @interface MetadataParameter
 */
export interface MetadataParameter {
    /**
     * 
     * @type {string}
     * @memberof MetadataParameter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataParameter
     */
    'type': string;
    /**
     * 
     * @type {Array<MetadataParameter>}
     * @memberof MetadataParameter
     */
    'children'?: Array<MetadataParameter>;
}
/**
 * 
 * @export
 * @interface MetadataSentence
 */
export interface MetadataSentence {
    /**
     * 
     * @type {string}
     * @memberof MetadataSentence
     */
    'entity': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataSentence
     */
    'dialect': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataSentence
     */
    'dataSource': string;
    /**
     * 
     * @type {string}
     * @memberof MetadataSentence
     */
    'sentence': string;
    /**
     * 
     * @type {Array<MetadataSentence>}
     * @memberof MetadataSentence
     */
    'children'?: Array<MetadataSentence>;
}
/**
 * 
 * @export
 * @interface Parameter
 */
export interface Parameter {
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    'type': string;
    /**
     * 
     * @type {any}
     * @memberof Parameter
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface Ping
 */
export interface Ping {
    /**
     * 
     * @type {string}
     * @memberof Ping
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof Ping
     */
    'time': string;
}
/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    'length'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'primaryKey'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'autoincrement'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'default'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'readValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'writeValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'enum'?: string;
}
/**
 * 
 * @export
 * @interface PropertyMapping
 */
export interface PropertyMapping {
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof PropertyMapping
     */
    'length'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyMapping
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyMapping
     */
    'primaryKey'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyMapping
     */
    'autoincrement'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'default'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'readValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'writeValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'enum'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'mapping': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMapping
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface QueryOptions
 */
export interface QueryOptions {
    /**
     * 
     * @type {string}
     * @memberof QueryOptions
     */
    'stage'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryOptions
     */
    'view'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryOptions
     */
    'chunkSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QueryOptions
     */
    'tryAllCan'?: boolean;
}
/**
 * 
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
    /**
     * 
     * @type {QueryOptions}
     * @memberof QueryRequest
     */
    'options'?: QueryOptions;
    /**
     * 
     * @type {string}
     * @memberof QueryRequest
     */
    'expression': string;
    /**
     * 
     * @type {any}
     * @memberof QueryRequest
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface QueryRequest
 */
export interface QueryQueuedRequest {
    /**
     * 
     * @type {QueryOptions}
     * @memberof QueryQueuedRequest
     */
    'options'?: QueryOptions;
    /**
     * 
     * @type {string}
     * @memberof QueryQueuedRequest
     */
    'expression': string;
    /**
     * 
     * @type {any}
     * @memberof QueryQueuedRequest
     */
    'data'?: any;
     /**
     * 
     * @type {string}
     * @memberof QueryQueuedRequest
     */
     'topic': string;
     /**
     * 
     * @type {number}
     * @memberof QueryQueuedRequest
     */
     'chunk'?: number;
}
/**
 * 
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
    /**
     * 
     * @type {any}
     * @memberof QueryResponse
     */
    'result': any;
}
/**
 * 
 * @export
 * @interface Relation
 */
export interface Relation {
    /**
     * 
     * @type {string}
     * @memberof Relation
     */
    'name': string;
    /**
     * 
     * @type {RelationType}
     * @memberof Relation
     */
    'type': RelationType;
    /**
     * 
     * @type {boolean}
     * @memberof Relation
     */
    'composite'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Relation
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof Relation
     */
    'entity': string;
    /**
     * 
     * @type {string}
     * @memberof Relation
     */
    'to': string;
    /**
     * 
     * @type {boolean}
     * @memberof Relation
     */
    'weak'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Relation
     */
    'target'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Relation
     */
    'targetComposite'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RelationType = {
    OneToMany: 'oneToMany',
    ManyToOne: 'manyToOne',
    OneToOne: 'oneToOne'
} as const;

export type RelationType = typeof RelationType[keyof typeof RelationType];


/**
 * 
 * @export
 * @interface RuleDataSource
 */
export interface RuleDataSource {
    /**
     * 
     * @type {string}
     * @memberof RuleDataSource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RuleDataSource
     */
    'condition'?: string;
}
/**
 * 
 * @export
 * @interface SchemaData
 */
export interface SchemaData {
    /**
     * 
     * @type {Array<SchemaDataEntity>}
     * @memberof SchemaData
     */
    'entities': Array<SchemaDataEntity>;
}
/**
 * 
 * @export
 * @interface SchemaDataEntity
 */
export interface SchemaDataEntity {
    /**
     * 
     * @type {string}
     * @memberof SchemaDataEntity
     */
    'entity': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof SchemaDataEntity
     */
    'rows': Array<any>;
}
/**
 * 
 * @export
 * @interface Stage
 */
export interface Stage {
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'name': string;
    /**
     * 
     * @type {Array<RuleDataSource>}
     * @memberof Stage
     */
    'dataSources': Array<RuleDataSource>;
}

/**
 * ExpressionApi - axios parameter creator
 * @export
 */
export const ExpressionApiAxiosParamCreator = function (configuration: Configuration) {
    return {
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constraints: async (queryRequest?: QueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/constraints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute: async (queryRequest: QueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryRequest' is not null or undefined
            assertParamExists('execute', 'queryRequest', queryRequest)
            const localVarPath = `/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadata: async (queryRequest?: QueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        model: async (queryRequest?: QueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameters: async (queryRequest?: QueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sentence: async (queryRequest: QueryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryRequest' is not null or undefined
            assertParamExists('sentence', 'queryRequest', queryRequest)
            const localVarPath = `/sentence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExpressionApi - functional programming interface
 * @export
 */
export const ExpressionApiFp = function(configuration: Configuration) {
    const localVarAxiosParamCreator = ExpressionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constraints(queryRequest?: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataConstraint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.constraints(queryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async execute(queryRequest: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.execute(queryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
         /**
         * 
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
         async executeQueued(queryQueuedRequest: QueryQueuedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.execute(queryQueuedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadata(queryRequest?: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadata(queryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async model(queryRequest?: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetadataModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.model(queryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parameters(queryRequest?: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MetadataParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parameters(queryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sentence(queryRequest: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataSentence>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sentence(queryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * ExpressionApi - factory interface
 * @export
 */
export const ExpressionApiFactory = function (configuration: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExpressionApiFp(configuration)
    return {
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constraints(queryRequest?: QueryRequest, options?: any): AxiosPromise<MetadataConstraint> {
            return localVarFp.constraints(queryRequest, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        execute(queryRequest: QueryRequest, options?: any): AxiosPromise<any> {
            return localVarFp.execute(queryRequest, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadata(queryRequest?: QueryRequest, options?: any): AxiosPromise<Metadata> {
            return localVarFp.metadata(queryRequest, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        model(queryRequest?: QueryRequest, options?: any): AxiosPromise<Array<MetadataModel>> {
            return localVarFp.model(queryRequest, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {QueryRequest} [queryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parameters(queryRequest?: QueryRequest, options?: any): AxiosPromise<Array<MetadataParameter>> {
            return localVarFp.parameters(queryRequest, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {QueryRequest} queryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sentence(queryRequest: QueryRequest, options?: any): AxiosPromise<MetadataSentence> {
            return localVarFp.sentence(queryRequest, options).then((request) => request(axios, configuration.basePath))
        },
    };
};

/**
 * ExpressionApi - object-oriented interface
 * @export
 * @class ExpressionApi
 * @extends {BaseAPI}
 */
export class ExpressionApi extends BaseAPI {
    /**
     * 
     * @param {QueryRequest} [queryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressionApi
     */
    public constraints(queryRequest?: QueryRequest, options?: AxiosRequestConfig) {
        return ExpressionApiFp(this.configuration).constraints(queryRequest, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {QueryRequest} queryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressionApi
     */
    public execute(queryRequest: QueryRequest, options?: AxiosRequestConfig) {
        return ExpressionApiFp(this.configuration).execute(queryRequest, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {QueryQueuedRequest} queryQueuedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressionApi
     */
    public executeQueued(queryQueuedRequest: QueryQueuedRequest, options?: AxiosRequestConfig) {
        return ExpressionApiFp(this.configuration).execute(queryQueuedRequest, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {QueryRequest} [queryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressionApi
     */
    public metadata(queryRequest?: QueryRequest, options?: AxiosRequestConfig) {
        return ExpressionApiFp(this.configuration).metadata(queryRequest, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {QueryRequest} [queryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressionApi
     */
    public model(queryRequest?: QueryRequest, options?: AxiosRequestConfig) {
        return ExpressionApiFp(this.configuration).model(queryRequest, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {QueryRequest} [queryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressionApi
     */
    public parameters(queryRequest?: QueryRequest, options?: AxiosRequestConfig) {
        return ExpressionApiFp(this.configuration).parameters(queryRequest, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {QueryRequest} queryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpressionApi
     */
    public sentence(queryRequest: QueryRequest, options?: AxiosRequestConfig) {
        return ExpressionApiFp(this.configuration).sentence(queryRequest, options).then((request) => request(this.axios, this.configuration.basePath))
    }
}


/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (configuration: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function(configuration: Configuration) {
    const localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (configuration: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): AxiosPromise<Health> {
            return localVarFp.health(options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(options?: any): AxiosPromise<any> {
            return localVarFp.metrics(options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<Ping> {
            return localVarFp.ping(options).then((request) => request(axios, configuration.basePath))
        },
    };
};

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public health(options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).health(options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public metrics(options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).metrics(options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public ping(options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.configuration.basePath))
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration: Configuration) {
    return {
        /**
         * 
         * @param {string} _enum 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _enum: async (_enum: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_enum' is not null or undefined
            assertParamExists('_enum', '_enum', _enum)
            const localVarPath = `/enums/{enum}`
                .replace(`{${"enum"}}`, encodeURIComponent(String(_enum)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSources: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/datasources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} datasource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasource: async (datasource: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasource' is not null or undefined
            assertParamExists('datasource', 'datasource', datasource)
            const localVarPath = `/datasources/{datasource}`
                .replace(`{${"datasource"}}`, encodeURIComponent(String(datasource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entities: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entity: async (entity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('entity', 'entity', entity)
            const localVarPath = `/entities/{entity}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mapping 
         * @param {string} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entityMapping: async (mapping: string, entity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mapping' is not null or undefined
            assertParamExists('entityMapping', 'mapping', mapping)
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('entityMapping', 'entity', entity)
            const localVarPath = `/mappings/{mapping}/{entity}`
                .replace(`{${"mapping"}}`, encodeURIComponent(String(mapping)))
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enums: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/enums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapping: async (mapping: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mapping' is not null or undefined
            assertParamExists('mapping', 'mapping', mapping)
            const localVarPath = `/mappings/{mapping}`
                .replace(`{${"mapping"}}`, encodeURIComponent(String(mapping)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stage: async (stage: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stage' is not null or undefined
            assertParamExists('stage', 'stage', stage)
            const localVarPath = `/stages/{stage}`
                .replace(`{${"stage"}}`, encodeURIComponent(String(stage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} _enum 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _enum(_enum: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Enum>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._enum(_enum, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataSources(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataSources(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} datasource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasource(datasource: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasource(datasource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entities(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entity(entity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entity(entity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} mapping 
         * @param {string} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entityMapping(mapping: string, entity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entityMapping(mapping, entity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enums(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Enum>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enums(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} mapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mapping(mapping: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mapping(mapping, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mappings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Mapping>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mappings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stage(stage: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stage(stage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Stage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration: Configuration, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * 
         * @param {string} _enum 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _enum(_enum: string, options?: any): AxiosPromise<Enum> {
            return localVarFp._enum(_enum, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataSources(options?: any): AxiosPromise<Array<DataSource>> {
            return localVarFp.dataSources(options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {string} datasource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasource(datasource: string, options?: any): AxiosPromise<DataSource> {
            return localVarFp.datasource(datasource, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entities(options?: any): AxiosPromise<Array<Entity>> {
            return localVarFp.entities(options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {string} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entity(entity: string, options?: any): AxiosPromise<Entity> {
            return localVarFp.entity(entity, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {string} mapping 
         * @param {string} entity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entityMapping(mapping: string, entity: string, options?: any): AxiosPromise<EntityMapping> {
            return localVarFp.entityMapping(mapping, entity, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enums(options?: any): AxiosPromise<Array<Enum>> {
            return localVarFp.enums(options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {string} mapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapping(mapping: string, options?: any): AxiosPromise<Mapping> {
            return localVarFp.mapping(mapping, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappings(options?: any): AxiosPromise<Array<Mapping>> {
            return localVarFp.mappings(options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stage(stage: string, options?: any): AxiosPromise<Stage> {
            return localVarFp.stage(stage, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stages(options?: any): AxiosPromise<Array<Stage>> {
            return localVarFp.stages(options).then((request) => request(axios, configuration.basePath))
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * 
     * @param {string} _enum 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public _enum(_enum: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration)._enum(_enum, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public dataSources(options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).dataSources(options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {string} datasource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public datasource(datasource: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).datasource(datasource, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public entities(options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).entities(options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {string} entity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public entity(entity: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).entity(entity, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {string} mapping 
     * @param {string} entity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public entityMapping(mapping: string, entity: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).entityMapping(mapping, entity, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public enums(options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).enums(options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {string} mapping 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public mapping(mapping: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).mapping(mapping, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public mappings(options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).mappings(options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {string} stage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public stage(stage: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).stage(stage, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public stages(options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).stages(options).then((request) => request(this.axios, this.configuration.basePath))
    }
}


/**
 * StageApi - axios parameter creator
 * @export
 */
export const StageApiAxiosParamCreator = function (configuration: Configuration) {
    return {
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (stage: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stage' is not null or undefined
            assertParamExists('_export', 'stage', stage)
            const localVarPath = `/stages/{stage}/export`
                .replace(`{${"stage"}}`, encodeURIComponent(String(stage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stage 
         * @param {SchemaData} schemaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import: async (stage: string, schemaData: SchemaData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stage' is not null or undefined
            assertParamExists('_import', 'stage', stage)
            // verify required parameter 'schemaData' is not null or undefined
            assertParamExists('_import', 'schemaData', schemaData)
            const localVarPath = `/stages/{stage}/import`
                .replace(`{${"stage"}}`, encodeURIComponent(String(stage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exists: async (stage: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stage' is not null or undefined
            assertParamExists('exists', 'stage', stage)
            const localVarPath = `/stages/{stage}/exists`
                .replace(`{${"stage"}}`, encodeURIComponent(String(stage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StageApi - functional programming interface
 * @export
 */
export const StageApiFp = function(configuration: Configuration) {
    const localVarAxiosParamCreator = StageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(stage: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(stage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} stage 
         * @param {SchemaData} schemaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _import(stage: string, schemaData: SchemaData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._import(stage, schemaData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exists(stage: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exists(stage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * StageApi - factory interface
 * @export
 */
export const StageApiFactory = function (configuration: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StageApiFp(configuration)
    return {
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(stage: string, options?: any): AxiosPromise<SchemaData> {
            return localVarFp._export(stage, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {string} stage 
         * @param {SchemaData} schemaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import(stage: string, schemaData: SchemaData, options?: any): AxiosPromise<any> {
            return localVarFp._import(stage, schemaData, options).then((request) => request(axios, configuration.basePath))
        },
        /**
         * 
         * @param {string} stage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exists(stage: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.exists(stage, options).then((request) => request(axios, configuration.basePath))
        },
    };
};

/**
 * StageApi - object-oriented interface
 * @export
 * @class StageApi
 * @extends {BaseAPI}
 */
export class StageApi extends BaseAPI {
    /**
     * 
     * @param {string} stage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StageApi
     */
    public _export(stage: string, options?: AxiosRequestConfig) {
        return StageApiFp(this.configuration)._export(stage, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {string} stage 
     * @param {SchemaData} schemaData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StageApi
     */
    public _import(stage: string, schemaData: SchemaData, options?: AxiosRequestConfig) {
        return StageApiFp(this.configuration)._import(stage, schemaData, options).then((request) => request(this.axios, this.configuration.basePath))
    }

    /**
     * 
     * @param {string} stage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StageApi
     */
    public exists(stage: string, options?: AxiosRequestConfig) {
        return StageApiFp(this.configuration).exists(stage, options).then((request) => request(this.axios, this.configuration.basePath))
    }
}


